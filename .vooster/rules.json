{
  "rules": [
    {
      "type": "prd",
      "content": "# 제품 요구 사항 문서 (PRD) – le feu\n\n## 1. 개요\nle feu는 셰프·외식업 종사자를 위한 콘텐츠 큐레이션, 업계 전용 커뮤니티, 직무 맞춤 채용보드를 결합한 웹 기반 플랫폼이다. 셰프 스토리 중심의 고품질 콘텐츠와 실질적 커뮤니티, 현장 용어 기반 채용 정보를 한번에 제공함으로써 업계 종사자의 커리어·연결·영감을 동시에 충족한다.\n\n## 2. 문제 정의\n- 기존 커뮤니티·구인구직 서비스는 요식업 특수성을 반영하지 못해 정보 파편화 발생  \n- 업계 용어·직무 특화 필터 부족으로 매칭 효율 저하  \n- 셰프 스토리를 접할 창구와 동료 네트워킹 공간 부재  \n- 결과: 종사자는 다수 채널을 전전하며 시간·비용·동기 소모\n\n## 3. 목표 및 목적\n- 1차 목표: 셰프 중심 콘텐츠·커뮤니티·채용을 원스톱 제공\n- 2차 목표  \n  - 업계 용어 기반 검색·매칭 정확도 30%↑  \n  - 활발한 커뮤니티로 월간 활성 게시물 1,000건 달성  \n- 성공 지표  \n  - MAU 10,000명, 재방문율 40% 이상  \n  - 월 채용 공고 500건, 지원-공고 매칭율 60%  \n  - 평균 체류 시간 5분 이상\n\n## 4. 타깃 사용자\n### 주요 사용자\n- 연령 20대 후반~40대 중반, 성별 무관  \n- 직군: 셰프, 주방보조, 매니저, 파트타이머, 지망생, 창업 준비자  \n- 니즈: 업계 인사이트·네트워크·채용 기회·영감\n### 이해관계자\n- 외식 사업주·인사 담당자  \n- 식자재·장비 브랜드(광고·제휴)  \n- 요리 학교·교육 기관\n\n## 5. 사용자 스토리\n- “셰프로서 최신 트렌드와 선배 스토리를 보고 영감을 얻고 싶다.”  \n- “주방보조로서 내 실력에 맞는 ‘엑스트라’ 포지션을 빠르게 찾고 싶다.”  \n- “매장 매니저로서 긴급 인력을 당일에 섭외하고 싶다.”  \n- “지망생으로서 익명으로 질문해 전문 조언을 받고 싶다.”\n\n## 6. 기능 요구 사항\n### 핵심 기능 (MVP)\n1. 셰프 큐레이션 피드  \n   - 카드형 썸네일, 스토리 요약, 상세 페이지  \n   - 수동·자동(태그) 큐레이션 혼합  \n   - 수락 조건: 3초 내 썸네일 로드, 클릭→상세 1초 내\n2. 커뮤니티  \n   - 글쓰기, 댓글, 좋아요, 북마크  \n   - 카테고리: 질문, 후기, 자유, 구인  \n   - 신고·차단·관리자 숨김 기능\n3. 채용보드  \n   - 업계 용어 기반 직군 필터(헬퍼/엑스트라/정규직)  \n   - 공고 등록, 지원, 저장, 마감 표시  \n   - 매칭 알림(이메일·웹푸시)\n4. 회원 가입·역할 기반 프로필  \n   - OAuth(Google, Apple) + 이메일  \n   - 역할 선택→맞춤 피드·채용 필터 자동 적용\n### 지원 기능\n- 검색·태그·정렬  \n- 반응형 UI(모바일 우선)  \n- 관리자 대시보드(콘텐츠·공고·신고 관리)\n\n## 7. 비기능 요구 사항\n- 성능: 95% 페이지 LCP 2.5초 이내  \n- 보안: OAuth 2.0, 비밀번호 해싱, HTTPS 상시  \n- 사용성: WCAG 2.1 AA 준수, 다크모드  \n- 확장성: 동시 접속 1만 명 처리  \n- 호환성: 최신 크롬·사파리·사파리(iOS)·크롬 안드로이드\n\n## 8. 기술 고려 사항\n- 아키텍처: Next.js + Vercel 서버리스, API Routes  \n- 프론트엔드: TypeScript, Tailwind CSS  \n- 백엔드/DB: Supabase(PostgreSQL), Airtable(콘텐츠 CMS)  \n- 인증: Firebase Auth 또는 Clerk (MVP 단계 선택)  \n- 커뮤니티 실시간: Supabase Realtime 채널  \n- 채용 알림: Firebase Cloud Messaging  \n- 분석: Google Analytics 4, Supabase 레포팅  \n- 3rd 파티: Cloudinary(이미지), SendGrid(메일)\n\n## 9. 성공 지표·KPI\n- 사용자: MAU, 신규 가입수, 7일 리텐션  \n- 콘텐츠: 평점 4.5/5 이상, 북마크 수  \n- 커뮤니티: 일평균 댓글 300+, 신고 처리 24h 이내  \n- 채용: 공고 당 평균 지원수 5명, 성사율 60%  \n- 기술: 오류율 <1%, 가동률 99.9%\n\n## 10. 일정·마일스톤\n| 단계 | 기간 | 주요 산출물 |\n|---|---|---|\n| 기획 동결 | 0~2주 | 상세 PRD, 와이어프레임 |\n| MVP 개발 | 3~10주 | 핵심 기능 완성, 내부 QA |\n| 베타 오픈 | 11~14주 | 외부 500명 초대, 피드백 수렴 |\n| 정식 출시 | 15~18주 | 버그 수정, 결제·광고 모듈 준비 |\n| 확장 단계 | 19주~ | 영상 인터뷰, 채팅, 알림 고도화 |\n\n## 11. 위험 및 대응\n- 기술: 실시간 기능 트래픽 폭증 → 캐싱·CDN, DB 파티셔닝  \n- 비즈니스: 초기 콘텐츠 부족 → 유명 셰프 5명 선계약, 공동 제작  \n- 사용자: 부적절 게시물 → AI 필터 + 24h 모더레이션  \n- 수익: 광고 의존도 높음 → 구독형 프리미엄, 교육 과정 확대\n\n## 12. 향후 고려\n- 셰프 영상 인터뷰(YouTube 연동)  \n- 실명/익명 전환 토글  \n- 구인자-지원자 1:1 채팅  \n- 셰프 포트폴리오(사진·레시피) 업로드  \n- 모바일 앱(PWA→네이티브)  \n- 다국어(영어·일어) 지원 및 해외 셰프 확장\n\n",
      "writedAt": "2025-07-27T09:36:12.916Z"
    },
    {
      "type": "architecture",
      "content": "# 기술 요구사항 문서 (TRD)\n\n## 1. 기술 개요\n\n### 프로젝트 개요\nle feu 프로젝트는 셰프 및 외식업 종사자를 위한 콘텐츠 큐레이션, 커뮤니티, 채용 정보를 통합 제공하는 웹 기반 플랫폼입니다. 본 TRD는 PRD의 요구사항을 충족시키기 위한 기술적 접근 방식과 아키텍처를 정의하며, 과도한 엔지니어링을 지양하고 효율적이고 확장 가능한 솔루션에 중점을 둡니다. Next.js, Supabase, Vercel 등 현대적인 서버리스 기술 스택을 활용하여 빠른 개발과 안정적인 운영을 목표로 합니다.\n\n### 핵심 기술 스택\n*   **프론트엔드**: Next.js (TypeScript), React, Tailwind CSS\n*   **백엔드/데이터베이스**: Supabase (PostgreSQL), Next.js API Routes (서버리스 함수)\n*   **콘텐츠 관리**: Airtable (초기 콘텐츠 CMS)\n*   **인증**: Firebase Auth (Google, Apple, 이메일, 전화번호)\n*   **실시간 통신**: Supabase Realtime\n*   **알림**: Firebase Cloud Messaging (FCM), SendGrid\n*   **이미지 처리**: Cloudinary\n*   **배포**: Vercel\n*   **모노레포**: Turborepo + pnpm\n\n### 주요 기술 목표\n*   **성능**: 95% 페이지 LCP 2.5초 이내 달성, 썸네일 3초, 상세 페이지 1초 로드 목표.\n*   **확장성**: 동시 접속 1만 명 처리 가능하도록 서버리스 아키텍처 및 데이터베이스 최적화.\n*   **보안**: OAuth 2.0, 전화번호 인증, HTTPS 상시 적용, 역할 기반 접근 제어(RBAC) 구현.\n*   **사용성**: 모바일 우선 반응형 UI, WCAG 2.1 AA 준수.\n*   **유지보수성**: 모노레포 구조를 통한 코드 재사용성 및 일관성 확보.\n\n### 주요 기술 가정\n*   Supabase의 PostgreSQL 데이터베이스는 초기 및 중기 트래픽을 충분히 감당할 수 있다.\n*   Firebase Auth 및 Supabase Realtime은 실시간 기능 및 인증 요구사항을 만족한다.\n*   Vercel의 서버리스 환경은 Next.js API Routes를 통해 백엔드 로직을 효율적으로 처리한다.\n*   Airtable은 초기 콘텐츠 큐레이션 및 관리에 적합하며, 추후 확장 시 별도 CMS 도입을 고려한다.\n\n## 2. 기술 스택\n\n| Category | Technology / Library | Reasoning (Why it's chosen for this project) |\n| :------- | :------------------- | :------------------------------------------- |\n| **프론트엔드** | Next.js | SSR/CSR 하이브리드 렌더링, SEO 최적화, 파일 시스템 기반 라우팅, Vercel 배포와의 시너지. |\n| | TypeScript | 타입 안정성 확보, 개발 생산성 향상, 대규모 프로젝트 유지보수 용이성. |\n| | React | 선언적 UI 개발, 컴포넌트 기반 재사용성, 활발한 커뮤니티 및 생태계. |\n| | Tailwind CSS | 유틸리티 우선 CSS 프레임워크, 빠른 UI 개발, 일관된 디자인 시스템 구축. |\n| **백엔드/데이터베이스** | Supabase (PostgreSQL) | BaaS(Backend as a Service) 형태로 빠른 개발 가능, PostgreSQL 기반의 안정성 및 확장성, RLS(Row Level Security)를 통한 강력한 보안 기능, Realtime 기능 내장. |\n| | Next.js API Routes | Vercel 서버리스 환경에 최적화된 백엔드 API 구현, 프론트엔드와 동일한 언어(TypeScript) 사용으로 개발 효율성 증대. |\n| | Airtable | 비개발자 친화적인 인터페이스로 초기 콘텐츠 큐레이션 및 관리 용이. |\n| **인증** | Firebase Auth | Google, Apple 소셜 로그인 및 이메일, 전화번호 인증 등 다양한 인증 방식 지원, Supabase와의 연동 용이성. |\n| **실시간 통신** | Supabase Realtime | Supabase DB와의 연동을 통한 실시간 데이터 동기화, 커뮤니티 댓글 및 알림 기능 구현에 적합. |\n| **알림** | Firebase Cloud Messaging (FCM) | 웹 푸시 알림 및 모바일 앱 푸시 알림 확장성, 공고 매칭 및 커뮤니티 반응 알림에 활용. |\n| | SendGrid | 안정적인 이메일 발송 서비스, 인증 메일 및 대량 알림 메일 발송에 활용. |\n| **이미지 처리** | Cloudinary | 이미지 업로드, 최적화, 리사이징, CDN 제공으로 성능 향상 및 스토리지 관리 효율화. |\n| **배포** | Vercel | Next.js에 최적화된 서버리스 배포 플랫폼, CI/CD 자동화, 빠른 배포 및 스케일링. |\n| **모노레포** | Turborepo + pnpm | 모노레포 빌드 시스템으로 여러 프로젝트(web, admin, packages)의 효율적인 관리, 빌드 캐싱을 통한 개발 속도 향상, pnpm을 통한 의존성 관리 최적화. |\n| **분석** | Google Analytics 4 (GA4) | 사용자 행동 분석, 이벤트 기반 데이터 수집, Supabase 레포팅과 연동하여 통합 분석. |\n| **기타** | React Query (또는 SWR) | 클라이언트 측 데이터 페칭 및 캐싱 관리, UI와 데이터 동기화 효율화. |\n\n## 3. 시스템 아키텍처 설계\n\n### 최상위 빌딩 블록\n*   **클라이언트 (Next.js 웹 애플리케이션)**: 사용자 인터페이스를 제공하며, React 컴포넌트와 Next.js의 페이지 라우팅 및 데이터 페칭 기능을 활용합니다. SSR/CSR 하이브리드 렌더링을 통해 초기 로딩 성능과 SEO를 최적화합니다.\n*   **백엔드 (Next.js API Routes / Supabase Edge Functions)**: 클라이언트의 요청을 처리하고 데이터베이스와 상호작용하는 서버리스 API 계층입니다. 인증, 데이터 CRUD, 비즈니스 로직을 담당합니다.\n*   **데이터베이스 (Supabase PostgreSQL)**: 모든 애플리케이션 데이터를 저장하고 관리하는 관계형 데이터베이스입니다. 사용자 정보, 콘텐츠, 커뮤니티 게시물, 채용 공고 등 핵심 데이터를 포함합니다.\n*   **인증 서비스 (Firebase Auth)**: 사용자 회원가입, 로그인, 세션 관리를 담당합니다. OAuth2.0 기반 소셜 로그인 및 전화번호 인증을 처리합니다.\n*   **실시간 서비스 (Supabase Realtime)**: 커뮤니티 댓글, 알림 등 실시간 데이터 동기화가 필요한 기능을 지원합니다. WebSocket 기반으로 클라이언트와 서버 간 양방향 통신을 제공합니다.\n*   **외부 서비스**: Cloudinary (이미지 처리), SendGrid (이메일), Firebase Cloud Messaging (푸시 알림), Airtable (콘텐츠 CMS) 등 특정 기능을 위한 외부 연동 서비스입니다.\n\n### 최상위 컴포넌트 상호작용 다이어그램\n\n```mermaid\ngraph TD\n    A[사용자 (웹 브라우저)] -->|HTTPS| B[Next.js 웹 애플리케이션 (Vercel)]\n    B -->|API 요청| C[Next.js API Routes (Vercel)]\n    C -->|DB 쿼리| D[Supabase PostgreSQL DB]\n    C -->|인증 요청| E[Firebase Auth]\n    C -->|이미지 업로드/처리| F[Cloudinary]\n    C -->|이메일 발송| G[SendGrid]\n    C -->|푸시 알림| H[Firebase Cloud Messaging]\n    B -->|실시간 구독| I[Supabase Realtime]\n    I --> D\n    J[콘텐츠 관리자] --> K[Airtable CMS]\n    K -->|데이터 동기화 (수동/자동)| D\n```\n\n*   **사용자 (웹 브라우저)**는 HTTPS를 통해 Vercel에 배포된 Next.js 웹 애플리케이션에 접속합니다.\n*   **Next.js 웹 애플리케이션**은 사용자 인터페이스를 렌더링하고, 데이터 요청을 **Next.js API Routes**로 보냅니다.\n*   **Next.js API Routes**는 비즈니스 로직을 수행하며, **Supabase PostgreSQL DB**에서 데이터를 조회하거나 저장합니다. 또한, **Firebase Auth**를 통해 사용자 인증을 처리하고, **Cloudinary**로 이미지 업로드 및 처리를 위임하며, **SendGrid**로 이메일을 발송하고, **Firebase Cloud Messaging**을 통해 푸시 알림을 보냅니다.\n*   **Supabase Realtime**은 **Supabase PostgreSQL DB**의 변경 사항을 실시간으로 감지하여 **Next.js 웹 애플리케이션**에 WebSocket을 통해 전달합니다.\n*   **콘텐츠 관리자**는 **Airtable CMS**를 통해 콘텐츠를 관리하며, 이 데이터는 **Supabase PostgreSQL DB**로 동기화됩니다.\n\n### 코드 조직 및 컨벤션\n**도메인 주도 조직 전략**\n*   **도메인 분리**: `apps/` 디렉토리 내에 `web` (메인 프론트엔드), `admin` (관리자 대시보드)과 같이 비즈니스 도메인별로 애플리케이션을 분리합니다. `packages/` 디렉토리 내에는 `ui`, `auth`, `utils` 등 공유 로직을 도메인 또는 기능 단위로 모듈화합니다.\n*   **계층 기반 아키텍처**: 각 애플리케이션 내에서 `pages`, `components`, `services`, `hooks`, `types` 등 역할별로 계층을 분리하여 관심사를 명확히 합니다. API Routes는 `pages/api` 내에 도메인별로 구조화합니다.\n*   **기능 기반 모듈**: 특정 기능(예: `curation`, `community`, `job`)과 관련된 컴포넌트, API 로직, 타입 정의 등을 하나의 디렉토리 내에 함께 배치하여 응집도를 높입니다.\n*   **공유 컴포넌트**: `packages/ui`에는 디자인 시스템 기반의 재사용 가능한 UI 컴포넌트를, `packages/auth`에는 인증 관련 로직을, `packages/utils`에는 공통 유틸리티 함수를 정의하여 코드 중복을 최소화합니다.\n\n**범용 파일 및 폴더 구조**\n```\n/\n├── apps/\n│   ├── web/                     # 메인 프론트엔드 애플리케이션 (Next.js)\n│   │   ├── public/              # 정적 파일\n│   │   ├── src/\n│   │   │   ├── app/             # Next.js 13+ App Router (또는 pages/)\n│   │   │   │   ├── (auth)/      # 인증 관련 라우트 그룹\n│   │   │   │   ├── api/         # Next.js API Routes\n│   │   │   │   │   ├── auth/\n│   │   │   │   │   ├── curations/\n│   │   │   │   │   ├── community/\n│   │   │   │   │   └── jobs/\n│   │   │   │   ├── curations/   # 셰프 큐레이션 도메인\n│   │   │   │   ├── community/   # 커뮤니티 도메인\n│   │   │   │   ├── jobs/        # 채용보드 도메인\n│   │   │   │   ├── layout.tsx   # 공통 레이아웃\n│   │   │   │   └── page.tsx     # 홈 페이지\n│   │   │   ├── components/      # 공통 UI 컴포넌트 (도메인 무관)\n│   │   │   ├── hooks/           # 공통 React Hooks\n│   │   │   ├── lib/             # 클라이언트 측 유틸리티, API 클라이언트 등\n│   │   │   ├── styles/          # 전역 스타일, Tailwind CSS 설정\n│   │   │   └── types/           # 전역 타입 정의\n│   │   ├── next.config.js\n│   │   ├── package.json\n│   │   └── tsconfig.json\n│   ├── admin/                   # 관리자 대시보드 애플리케이션 (Next.js)\n│   │   ├── public/\n│   │   ├── src/\n│   │   │   ├── app/\n│   │   │   │   ├── api/\n│   │   │   │   ├── dashboard/\n│   │   │   │   ├── users/\n│   │   │   │   └── ...\n│   │   │   ├── components/\n│   │   │   ├── lib/\n│   │   │   └── ...\n│   │   ├── next.config.js\n│   │   ├── package.json\n│   │   └── tsconfig.json\n│   └── marketing/               # 마케팅/랜딩 페이지 (선택 사항)\n│       └── ...\n├── packages/\n│   ├── ui/                      # 공통 UI 컴포넌트 (Tailwind CSS 기반)\n│   │   ├── src/\n│   │   │   ├── components/\n│   │   │   │   ├── Button.tsx\n│   │   │   │   ├── Card.tsx\n│   │   │   │   └── ...\n│   │   │   └── index.ts\n│   │   ├── package.json\n│   │   └── tsconfig.json\n│   ├── auth/                    # 인증 관련 공통 로직 (Firebase Auth 연동)\n│   │   ├── src/\n│   │   │   ├── client/          # 클라이언트 측 인증 헬퍼\n│   │   │   ├── server/          # 서버 측 인증 헬퍼 (API Routes용)\n│   │   │   ├── types/\n│   │   │   └── index.ts\n│   │   ├── package.json\n│   │   └── tsconfig.json\n│   ├── utils/                   # 공통 유틸리티 함수 (날짜, 포맷, 유효성 검사 등)\n│   │   ├── src/\n│   │   │   ├── date.ts\n│   │   │   ├── format.ts\n│   │   │   └── ...\n│   │   ├── package.json\n│   │   └── tsconfig.json\n│   ├── config/                  # 공통 설정 파일 (ESLint, Prettier, TypeScript 등)\n│   │   ├── eslint-preset.js\n│   │   ├── tsconfig-base.json\n│   │   └── ...\n│   └── types/                   # 전역적으로 사용되는 공통 타입 정의 (선택 사항, utils에 포함 가능)\n│       ├── src/\n│       │   └── index.ts\n│       ├── package.json\n│       └── tsconfig.json\n├── .env.example\n├── .gitignore\n├── package.json                 # 모노레포 워크스페이스 정의 (pnpm-workspace.yaml)\n├── pnpm-lock.yaml\n├── pnpm-workspace.yaml          # pnpm 워크스페이스 설정\n└── turbo.json                   # Turborepo 설정\n```\n\n### 데이터 흐름 및 통신 패턴\n*   **클라이언트-서버 통신**:\n    *   Next.js 웹 애플리케이션은 `fetch` API 또는 `React Query`와 같은 라이브러리를 사용하여 Next.js API Routes (서버리스 함수)로 HTTP 요청(GET, POST, PUT, DELETE)을 보냅니다.\n    *   API 응답은 JSON 형태로 `status`, `data`, `message` 구조를 따르며, 에러 발생 시 표준 HTTP 상태 코드(401, 403, 500 등)와 함께 에러 메시지를 반환합니다.\n    *   인증이 필요한 요청에는 JWT 기반의 인증 헤더를 포함합니다.\n*   **데이터베이스 상호작용**:\n    *   Next.js API Routes는 Supabase 클라이언트 라이브러리(`@supabase/supabase-js`)를 사용하여 Supabase PostgreSQL 데이터베이스와 상호작용합니다.\n    *   SQL 쿼리는 Supabase의 ORM 기능을 활용하거나 직접 SQL 쿼리를 작성하여 실행합니다.\n    *   데이터베이스 접근은 Row Level Security (RLS) 정책을 통해 제어됩니다.\n*   **외부 서비스 통합**:\n    *   **인증**: 클라이언트는 Firebase Auth SDK를 통해 소셜 로그인 및 전화번호 인증을 수행하고, 성공 시 JWT 토큰을 발급받아 API 요청에 사용합니다.\n    *   **이미지**: Cloudinary SDK를 사용하여 이미지를 직접 업로드하고, 반환된 URL을 Supabase DB에 저장합니다.\n    *   **이메일**: Next.js API Routes에서 SendGrid API를 호출하여 이메일을 발송합니다.\n    *   **푸시 알림**: Next.js API Routes에서 Firebase Admin SDK를 사용하여 FCM에 푸시 알림 메시지를 전송합니다.\n    *   **콘텐츠 CMS**: Airtable에서 관리되는 콘텐츠는 주기적으로 또는 수동으로 Supabase DB로 동기화됩니다.\n*   **실시간 통신**:\n    *   커뮤니티 댓글, 알림 등 실시간 업데이트가 필요한 기능은 Supabase Realtime 채널을 구독하여 WebSocket을 통해 데이터를 수신합니다.\n    *   클라이언트는 Supabase Realtime SDK를 사용하여 특정 테이블 또는 채널의 변경 사항을 실시간으로 반영합니다.\n*   **데이터 동기화**:\n    *   클라이언트 측에서는 `React Query`의 캐싱 및 `stale-while-revalidate` 전략을 활용하여 데이터 일관성을 유지하고 불필요한 API 호출을 줄입니다.\n    *   서버 측에서는 ISR(Incremental Static Regeneration)을 활용하여 자주 변경되지 않는 콘텐츠(예: 큐레이션 피드)의 캐싱 및 주기적인 업데이트를 관리합니다.\n\n## 4. 성능 및 최적화 전략\n\n*   **이미지 최적화**: Cloudinary를 통해 모든 사용자 업로드 이미지를 최적화하고, WebP/AVIF 등 최신 포맷으로 변환하며, CDN을 통해 제공하여 로딩 속도를 단축합니다. Next.js의 `Image` 컴포넌트를 사용하여 Lazy Loading 및 반응형 이미지를 구현합니다.\n*   **데이터 페칭 및 캐싱**:\n    *   **SSR/ISR 활용**: 초기 로딩 속도 및 SEO를 위해 Next.js의 `getServerSideProps` 또는 `getStaticProps` (ISR 포함)를 활용하여 서버에서 데이터를 미리 페칭합니다. 특히 큐레이션 피드와 같이 자주 변경되지 않지만 중요한 콘텐츠에 ISR을 적용하여 빌드 시간을 줄이고 최신 데이터를 제공합니다.\n    *   **클라이언트 캐싱**: `React Query`를 사용하여 클라이언트 측에서 API 응답을 캐싱하고, `stale-while-revalidate` 전략을 통해 사용자 경험을 개선합니다.\n*   **데이터베이스 쿼리 최적화**:\n    *   PostgreSQL의 인덱스를 적절히 활용하여 쿼리 성능을 최적화합니다. 특히 `created_at`, `role`, `type`, `tags` 등 필터링 및 정렬에 사용되는 컬럼에 인덱스를 생성합니다.\n    *   복잡한 조인이나 집계 쿼리는 뷰(View) 또는 구체화된 뷰(Materialized View)를 활용하여 성능을 개선합니다.\n*   **서버리스 함수 최적화**: Next.js API Routes는 경량화된 로직으로 구성하여 콜드 스타트(Cold Start) 시간을 최소화하고, Vercel의 엣지 캐싱 기능을 활용하여 API 응답 속도를 향상시킵니다.\n\n## 5. 구현 로드맵 및 마일스톤\n\n### 1단계: 기반 구축 (MVP 구현)\n*   **핵심 인프라**: Next.js 프로젝트 초기 설정, Turborepo 모노레포 구성, Supabase DB 및 Firebase Auth 연동. Vercel 배포 파이프라인 구축.\n*   **필수 기능**:\n    *   회원 가입 및 로그인 (OAuth + 이메일 + 전화번호 인증, 역할 기반 프로필)\n    *   셰프 큐레이션 피드 (카드형 썸네일, 스토리 요약, 상세 페이지)\n    *   커뮤니티 (글쓰기, 댓글, 좋아요, 북마크, 카테고리)\n    *   채용보드 (공고 열람, 업계 용어 기반 필터, 공고 등록, 지원, 저장)\n*   **기본 보안**: HTTPS 적용, Supabase RLS 설정, JWT 기반 인증.\n*   **개발 환경 설정**: 개발/스테이징/운영 환경 분리, CI/CD 초기 설정.\n*   **예상 완료 기간**: 3~10주\n\n### 2단계: 기능 강화\n*   **고급 기능**:\n    *   매칭 알림 (이메일, 웹 푸시)\n    *   콘텐츠/공고 검색, 태그, 정렬 기능 고도화\n    *   관리자 대시보드 (콘텐츠/공고/신고 관리, 사용자 차단)\n    *   WCAG 2.1 AA 준수 및 다크모드 지원\n*   **성능 최적화**: LCP 2.5초 이내 달성, 이미지 최적화, API 캐싱 전략 강화.\n*   **보안 강화**: Rate Limiting, ReCaptcha 도입 검토, 관리자 2FA 적용.\n*   **모니터링 구현**: GA4 연동, Supabase 레포팅을 통한 핵심 지표 추적.\n*   **예상 완료 기간**: 11~18주\n\n### 3단계: 확장 및 최적화\n*   **확장성 구현**: 동시 접속 1만 명 처리를 위한 DB 파티셔닝 또는 샤딩 검토, Cloudflare CDN 도입.\n*   **고급 통합**: Notion API 연동을 통한 콘텐츠 자동화, Zapier/Make를 통한 운영 자동화.\n*   **엔터프라이즈 기능**: 셰프 포트폴리오 기능, 1:1 채팅 기능 (향후 고려).\n*   **규정 준수 및 감사**: 개인정보 보호법 준수 강화, 감사 로그 시스템 구축.\n*   **예상 완료 기간**: 19주~\n\n## 6. 위험 평가 및 완화 전략\n\n### 기술적 위험 분석\n*   **기술 위험**:\n    *   **잠재적 문제**: Supabase의 특정 기능(예: Realtime 성능, RLS 복잡성)이 예상보다 제한적이거나 학습 곡선이 높을 수 있음.\n    *   **완화 전략**: Supabase 공식 문서 및 커뮤니티 적극 활용, 필요 시 Supabase 지원팀과 협력. 핵심 기능에 대한 PoC(개념 증명)를 통해 기술 적합성 사전 검증.\n*   **성능 위험**:\n    *   **잠재적 문제**: 동시 접속자 증가 시 DB 부하, API 응답 지연, 실시간 기능의 병목 현상 발생 가능성.\n    *   **완화 전략**:\n        *   DB: 인덱스 최적화, 쿼리 튜닝, Supabase의 스케일링 옵션 검토. 필요 시 읽기 전용 복제본(Read Replica) 도입.\n        *   API: Vercel 서버리스 함수의 메모리/CPU 최적화, 엣지 캐싱 적극 활용.\n        *   실시간: Supabase Realtime 채널의 효율적 사용, 불필요한 데이터 전송 최소화.\n*   **보안 위험**:\n    *   **잠재적 문제**: 인증 우회, 데이터 유출, 악성 사용자 활동(스팸, 어뷰징)으로 인한 서비스 품질 저하.\n    *   **완화 전략**:\n        *   인증: Firebase Auth의 보안 기능(다단계 인증, 세션 관리) 적극 활용.\n        *   데이터: Supabase RLS를 통한 엄격한 접근 제어, 모든 민감 데이터 암호화 저장.\n        *   어뷰징: Rate Limiting, ReCaptcha 도입, 관리자 대시보드를 통한 신고/차단 기능 강화, AI 기반 키워드 필터링 도입 검토.\n*   **통합 위험**:\n    *   **잠재적 문제**: 외부 서비스(Cloudinary, SendGrid, FCM 등)의 API 변경, 서비스 중단, 비용 증가.\n    *   **완화 전략**: 각 서비스의 SLA(서비스 수준 협약) 확인, API 변경에 대한 주기적인 모니터링 및 업데이트. 핵심 기능에 대한 대체 서비스 검토(예: Cloudinary 대신 Supabase Storage 활용).\n\n### 프로젝트 제공 위험\n*   **일정 위험**:\n    *   **잠재적 문제**: MVP 개발 일정 지연, 예상치 못한 기술적 난이도 발생.\n    *   **완화 전략**: 애자일 개발 방법론 적용, 스프린트 단위 목표 설정 및 주기적인 진행 상황 검토. 핵심 기능 우선 개발 및 점진적 기능 확장.\n*   **자원 위험**:\n    *   **잠재적 문제**: 개발 인력 부족, 특정 기술 스택에 대한 전문성 부족.\n    *   **완화 전략**: 핵심 개발자 역량 강화 교육, 필요 시 외부 전문가 자문 또는 채용 검토. 모노레포 구조를 통해 팀 간 협업 효율 증대.\n*   **품질 위험**:\n    *   **잠재적 문제**: 코드 품질 저하, 버그 발생률 증가, 사용자 경험 저해.\n    *   **완화 전략**: TypeScript 적극 활용, 코드 리뷰 의무화, Jest/React Testing Library를 활용한 단위/통합 테스트 코드 작성. E2E 테스트(Playwright/Cypress) 도입 검토.\n*   **배포 위험**:\n    *   **잠재적 문제**: 프로덕션 환경 배포 시 문제 발생, 롤백의 어려움.\n    *   **완화 전략**: Vercel의 자동화된 CI/CD 파이프라인 활용, 스테이징 환경에서 충분한 테스트 진행 후 프로덕션 배포. 배포 전 체크리스트 작성 및 준수.\n*   **비상 계획**:\n    *   주요 서비스 장애 시 대응 매뉴얼 수립.\n    *   데이터 백업 및 복구 전략 수립 (Supabase 자동 백업 활용 및 주기적 수동 백업 검토).\n    *   긴급 상황 발생 시 팀 내 비상 연락망 구축 및 역할 분담.",
      "writedAt": "2025-07-27T09:36:12.916Z"
    },
    {
      "type": "guideline",
      "content": "# le feu: 코드 가이드라인 문서 (Code Guideline)\n\n> **목적:** 이 문서는 `le feu` 프로젝트의 코드 품질과 유지보수성을 보장하기 위해 모든 팀원이 따라야 할 개발 표준을 정의합니다.\n\n---\n\n## 1. 프로젝트 개요\n\nle feu는 요식업 종사자 전용 콘텐츠 큐레이션 + 커뮤니티 + 구인/구직 기능을 제공하는 웹 기반 플랫폼입니다.\n\n**핵심 기술 스택 및 구조:**\n- **Monorepo:** `Turborepo + pnpm`\n- **Frontend:** `Next.js`, `React`, `TypeScript`, `Tailwind CSS`\n- **Backend/API:** `Next.js API Routes` (Serverless) + `Supabase` (PostgreSQL)\n- **Auth:** `Firebase Auth + Phone 인증 (번호 인증)`\n- **Realtime:** `Supabase Realtime`\n- **CI/CD & Hosting:** `Vercel`\n- **CMS/Analytics:** `Airtable`, `GA4`\n- **3rd-party:** `SendGrid`, `Cloudinary`, `Sentry`\n\n---\n\n## 2. 핵심 개발 원칙 (Principles)\n\n| 원칙 | 설명 |\n|------|------|\n| **가독성 (Readability)** | 누구나 이해할 수 있도록 명확하게 작성 |\n| **일관성 (Consistency)** | 파일 구조, 변수명, 코드 스타일 통일 |\n| **유지보수성 (Maintainability)** | 확장, 디버깅, 리팩토링이 쉬운 구조 |\n| **성능 (Performance)** | 최소 로딩 시간, 최적화된 API 호출 |\n| **보안 (Security)** | 사용자 데이터 보호, 인증/인가 철저 |\n\n---\n\n## 3. 프로젝트 구조\n\n```\n/apps\n  web/           # 사용자 웹앱 (Next.js)\n  admin/         # 관리자 페이지 (Next.js)\n/packages\n  ui/            # 디자인 시스템\n  auth/          # 인증 로직 모듈화\n  utils/         # 공통 유틸리티\n```\n\n---\n\n## 4. 코드 작성 규칙\n\n### ✅ 반드시 지켜야 할 규칙 (MUST)\n\n- `PascalCase`: React 컴포넌트, 타입/인터페이스\n- `camelCase`: 함수, 변수, state\n- `snake_case`: DB 컬럼명\n- `kebab-case`: Tailwind 커스텀 className\n\n### ✅ API & 비동기 처리\n\n- 모든 API는 `/api/*`에서 RESTful하게 구성\n- `try/catch`로 에러 핸들링, 사용자 피드백 필수\n- 오류는 `Sentry`, `Vercel 로그`, `console.error` 중 하나 이상으로 반드시 로깅\n- 응답은 `{ data: T, message?: string }` 또는 `{ error: string }` 형식 통일\n\n### ✅ 데이터 패칭\n\n- 클라이언트: `React Query` (useQuery/useMutation)\n- 서버사이드: `getStaticProps`, `getServerSideProps` (필요 시)\n- 반드시 API 경유. React 컴포넌트 내에서 직접 DB 접근 ❌\n\n### ✅ 상태 관리\n\n- **서버 상태**: `React Query`\n- **로컬 상태**: `useState`, `useReducer`\n- **전역 상태**: `Zustand` or `React Context` (단, 최소화)\n\n### ✅ 폼 관리\n\n- `react-hook-form` + `Zod` 또는 `Yup`으로 validation\n\n---\n\n## 5. 코드 스타일 도구\n\n- **ESLint**: Airbnb 기반 커스터마이징\n- **Prettier**: 팀 통일된 포맷 자동 적용\n- **Example .eslintrc.js**:\n```js\nmodule.exports = {\n  extends: [\"next\", \"airbnb\", \"plugin:@typescript-eslint/recommended\", \"prettier\"],\n  plugins: [\"@typescript-eslint\", \"react-hooks\"],\n  rules: {\n    \"react/react-in-jsx-scope\": \"off\",\n    \"@typescript-eslint/no-explicit-any\": \"warn\"\n  }\n}\n```\n\n---\n\n## 6. 테스트 & QA\n\n| 항목 | 도구 |\n|------|------|\n| **단위 테스트** | `Jest` + `React Testing Library` |\n| **E2E 테스트** | `Playwright` or `Cypress` |\n| **CI 테스트 조건** | PR 생성 시 Lint + Test 자동 수행 (GitHub Actions 설정)\n\n```yaml\n# .github/workflows/ci.yml\n- run: npm run lint\n- run: npm run test\n```\n\n---\n\n## 7. 보안 및 인증\n\n- 모든 인증은 `Firebase Auth + Phone 인증` 사용\n- 인증된 사용자만 접근 가능한 API는 `JWT` 기반으로 보호\n- **RBAC**(역할 기반 권한): 관리자/사업주/일반회원 구분\n- 비밀번호는 bcrypt 해시 저장, HTTPS 항상 유지\n- `Supabase RLS` 활성화: 유저 소유 데이터만 접근 허용\n\n---\n\n## 8. 환경 변수 관리\n\n- `.env.example`을 반드시 제공\n- **Private** 정보는 클라이언트에 노출 금지\n- 예시:\n```\nNEXT_PUBLIC_SUPABASE_URL=https://xyz.supabase.co\nSUPABASE_SERVICE_ROLE_KEY=xxxxx   # ❌ 클라이언트 노출 금지\nSENDGRID_API_KEY=xxx\n```\n\n---\n\n## 9. 기타 주의사항\n\n- `getServerSideProps` 남용 금지 → `getStaticProps + ISR` 우선 고려\n- Tailwind class 남용 지양. 필요한 경우 `clsx`, `classnames` 활용\n- 500줄 넘는 파일은 무조건 분리 (단일 책임 원칙)\n- `console.log`는 개발 중에도 최소화, 배포 시 제거\n\n---\n\n## 10. 마무리\n\n이 가이드는 팀 전체의 **일관성 있는 코드 작성**, **빠른 온보딩**, **에러 최소화**, **유지보수 효율성**을 위해 반드시 준수되어야 합니다.\n\n→ 위반 시 PR 리뷰 단계에서 수정 요청 가능\n→ 보완이 필요한 내용은 GitHub Discussion 또는 Notion에서 논의 후 반영\n\n---\n\n> 🔐 *le feu 팀의 모든 개발자는 이 가이드라인을 기반으로 작업해야 합니다.*\n> \n> ✍️ Created by ChatGPT & Vooster 기반 설계 반영",
      "writedAt": "2025-07-27T09:36:12.916Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-07-27T09:36:12.916Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-07-27T09:36:12.916Z"
    },
    {
      "type": "git-commit-message",
      "content": "\n# Git Commit Message Rules\n\n## Format Structure\n```\n<type>(<scope>): <description>\n\n[optional body]\n\n[optional footer]\n```\n\n## Types (Required)\n- `feat`\n- `fix`\n- `docs`\n- `style`\n- `refactor`\n- `perf`\n- `test`\n- `chore`\n- `ci`\n- `build`\n- `revert`\n\n## Scope (Optional)\n- Component, file, or feature area affected\n- Use kebab-case: `user-auth`, `payment-api`\n- Omit if change affects multiple areas\n\n## Description Rules\n- Use imperative mood\n- No capitalization of first letter\n- No period at end\n- Max 50 characters\n- Be specific and actionable\n\n## Body Guidelines\n- Wrap at 72 characters\n- Explain what and why, not how\n- Separate from description with blank line\n- Use bullet points for multiple changes\n\n## Footer Format\n- `BREAKING CHANGE:` for breaking changes\n- `Closes #123` for issue references\n- `Co-authored-by: Vooster AI (@vooster-ai)`\n\n## Examples\n```\nfeat(auth): add OAuth2 Google login\n\nfix: resolve memory leak in user session cleanup\n\ndocs(api): update authentication endpoints\n\nrefactor(utils): extract validation helpers to separate module\n\nBREAKING CHANGE: remove deprecated getUserData() method\n```\n\n## Workflow Integration\n**ALWAYS write a commit message after completing any development task, feature, or bug fix.**\n\n## Validation Checklist\n- [ ] Type is from approved list\n- [ ] Description under 50 chars\n- [ ] Imperative mood used\n- [ ] No trailing period\n- [ ] Meaningful and clear context\n    ",
      "writedAt": "2025-07-27T09:36:12.916Z"
    },
    {
      "type": "isms-p",
      "content": "\n# ISMS-P Based Secure Development Rules (v1.0)\n# This document defines the mandatory security rules for developers during code implementation.\n# Reference: Based on the Information Security Management System - Personal Information (ISMS-P) standard.\n\n## 1. Authentication & Authorization\n- **(A-1) User Identification and Authentication**\n  - **MUST**: Every user must be individually identifiable. The use of shared accounts is prohibited.\n  - **MUST**: Passwords MUST satisfy one of the following policies:\n    - (a) 8+ characters with a mix of letters, numbers, and special characters.\n    - (b) 10+ characters with a mix of letters and numbers.\n  - **MUST**: An account lockout policy MUST be implemented for failed login attempts (e.g., lock the account for 5 minutes after 5 consecutive failures).\n\n- **(A-2) Management of Authentication Credentials**\n  - **MUST**: Authentication credentials such as passwords MUST be stored using an adaptive hash function like **bcrypt, scrypt, or Argon2**. (Using SHA-256 alone is prohibited).\n\n- **(A-3) Privilege Management**\n  - **MUST**: Grant only the minimum necessary privileges for a role, following the **Principle of Least Privilege**.\n  - **MUST**: All actions of granting, changing, and revoking privileges MUST be logged.\n\n- **(A-4) Privileged Access Management**\n  - **MUST**: Administrative privileges (e.g., root, admin) MUST be granted to a minimum number of users, and the reason for using such accounts MUST be clearly logged.\n  - **SHOULD**: Administrative accounts SHOULD be separate from regular user accounts.\n\n## 2. Access Control\n- **(AC-1) System Access**\n  - **MUST**: Access to information systems by unauthorized users MUST be blocked.\n  - **MUST**: Access logs for critical systems MUST be retained for **at least one year**.\n\n- **(AC-2) Network Access**\n  - **MUST**: Public-facing services MUST be located in a **DMZ**, separate from the internal network.\n  - **MUST**: Firewalls MUST allow only the minimum necessary ports required for the service. (Prohibit \"allow all\" rules).\n\n## 3. Cryptography\n- **(C-1) Encryption of Sensitive Information**\n  - **MUST**: Legally defined sensitive information (e.g., national ID numbers, passport numbers, bank account numbers, credit card numbers) and passwords MUST be encrypted during storage and transmission.\n  - **MUST**: Use secure and vetted cryptographic algorithms such as **AES-256**.\n  - **MUST NOT**: Do not use homegrown or custom-developed cryptographic algorithms.\n\n- **(C-2) Cryptographic Key Management**\n  - **MUST NOT**: Do not hardcode cryptographic keys in source code, configuration files, or comments.\n  - **MUST**: Cryptographic keys MUST be managed securely using **environment variables** or a dedicated **Key Management System (KMS, HSM)**.\n  - **MUST**: Minimize access to keys and log all lifecycle management procedures, including generation, use, and destruction.\n\n## 4. Secure Development\n- **(D-1) Secure Design**\n  - **MUST**: Defense mechanisms against major vulnerabilities like the **OWASP Top 10** (e.g., SQL Injection, XSS, CSRF) MUST be incorporated during the design phase.\n\n- **(D-2) Secure Coding**\n  - **MUST**: Treat all external input (e.g., request parameters, headers, cookies) as untrusted. **Validation and sanitization** logic MUST always be applied.\n  - **MUST**: All SQL queries MUST use **parameterized queries (prepared statements)**. (Dynamic query string concatenation is prohibited).\n  - **MUST**: When handling errors, ensure that internal system details (e.g., stack traces, database information) are not exposed to the user.\n\n- **(D-3) Security Testing**\n  - **SHOULD**: Periodically scan for security vulnerabilities using static/dynamic analysis tools (**SAST/DAST**).\n\n## 5. Personal Information Handling\n- **(P-1) Collection and Use**\n  - **MUST**: Collect only the minimum personal information necessary to provide the service. The purpose of collection MUST be clearly disclosed to users, and consent must be obtained.\n  - **MUST NOT**: Do not process sensitive information (e.g., beliefs, ideology) or unique identification information without a legal basis or separate user consent.\n\n- **(P-2) Storage and Display**\n  - **MUST**: Personal information MUST be **masked** when displayed on screen (e.g., John D**, +1-***-***-1234, test@****.com).\n  - **MUST NOT**: Do not use personal information or provide it to third parties beyond the scope of the consented purpose.\n\n- **(P-3) Destruction**\n  - **MUST**: When the retention period expires or the processing purpose is achieved, personal information MUST be completely destroyed using an irreversible method.\n  - **MUST**: Establish a personal information destruction procedure and maintain a log of all destructions.\n\n## 6. Logging & Management\n- **(L-1) Log Recording**\n  - **MUST**: Logs for critical activities (e.g., login, access to personal information, privilege changes) MUST be securely retained for **at least one year**.\n  - **MUST**: Logs MUST be standardized and include at least the following: [Timestamp, User ID, Source IP Address, Request/Action, Success/Failure Status].\n",
      "writedAt": "2025-07-27T09:36:12.916Z"
    }
  ]
}